
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>LiSE &#8212; LiSE 0.9dev documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ELiDE" href="../ELiDE/index.html" />
    <link rel="prev" title="allegedb" href="../allegedb/index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="lise">
<h1>LiSE<a class="headerlink" href="#lise" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="module-LiSE.engine">
<span id="engine"></span><h2>engine<a class="headerlink" href="#module-LiSE.engine" title="Permalink to this headline">¶</a></h2>
<p>The “engine” of LiSE is an object relational mapper with special
stores for game data and entities, as well as properties for manipulating the
flow of time.</p>
<dl class="class">
<dt id="LiSE.engine.AbstractEngine">
<em class="property">class </em><code class="descclassname">LiSE.engine.</code><code class="descname">AbstractEngine</code><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent class to the real Engine as well as EngineProxy.</p>
<p>Implements serialization methods and the __getattr__ for stored methods.</p>
<p>By default, the deserializers will refuse to create LiSE entities. If
you want them to, use my <code class="docutils literal notranslate"><span class="pre">loading</span></code> property to open a <code class="docutils literal notranslate"><span class="pre">with</span></code> block,
in which deserialized entities will be created as needed.</p>
<dl class="method">
<dt id="LiSE.engine.AbstractEngine.coinflip">
<code class="descname">coinflip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.coinflip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.coinflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True or False with equal probability.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.AbstractEngine.contextmanager">
<code class="descname">contextmanager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.AbstractEngine.contextmanager" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;contextmanager decorator.</p>
<p>Typical usage:</p>
<blockquote>
<div><p>&#64;contextmanager
def some_generator(&lt;arguments&gt;):</p>
<blockquote>
<div><p>&lt;setup&gt;
try:</p>
<blockquote>
<div>yield &lt;value&gt;</div></blockquote>
<dl class="docutils">
<dt>finally:</dt>
<dd>&lt;cleanup&gt;</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>This makes this:</p>
<blockquote>
<div><dl class="docutils">
<dt>with some_generator(&lt;arguments&gt;) as &lt;variable&gt;:</dt>
<dd>&lt;body&gt;</dd>
</dl>
</div></blockquote>
<p>equivalent to this:</p>
<blockquote>
<div><p>&lt;setup&gt;
try:</p>
<blockquote>
<div>&lt;variable&gt; = &lt;value&gt;
&lt;body&gt;</div></blockquote>
<dl class="docutils">
<dt>finally:</dt>
<dd>&lt;cleanup&gt;</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.AbstractEngine.dice">
<code class="descname">dice</code><span class="sig-paren">(</span><em>n</em>, <em>d</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.dice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.dice" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll <code class="docutils literal notranslate"><span class="pre">n</span></code> dice with <code class="docutils literal notranslate"><span class="pre">d</span></code> faces, and yield the results.</p>
<p>This is an iterator. You’ll get the result of each die in
successon.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.AbstractEngine.dice_check">
<code class="descname">dice_check</code><span class="sig-paren">(</span><em>n</em>, <em>d</em>, <em>target</em>, <em>comparator='&lt;='</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.dice_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.dice_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll <code class="docutils literal notranslate"><span class="pre">n</span></code> dice with <code class="docutils literal notranslate"><span class="pre">d</span></code> sides, sum them, and return whether they
are &lt;= <code class="docutils literal notranslate"><span class="pre">target</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">comparator</span></code> is provided, use it instead of &lt;=. You may
use a string like ‘&lt;’ or ‘&gt;=’.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.AbstractEngine.loading">
<code class="descname">loading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.loading"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.loading" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for when you need to instantiate entities upon unpacking</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.AbstractEngine.percent_chance">
<code class="descname">percent_chance</code><span class="sig-paren">(</span><em>pct</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.percent_chance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.percent_chance" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a <code class="docutils literal notranslate"><span class="pre">pct``%</span> <span class="pre">chance</span> <span class="pre">of</span> <span class="pre">something</span> <span class="pre">happening</span> <span class="pre">right</span> <span class="pre">now,</span> <span class="pre">decide</span> <span class="pre">at</span>
<span class="pre">random</span> <span class="pre">whether</span> <span class="pre">it</span> <span class="pre">actually</span> <span class="pre">happens,</span> <span class="pre">and</span> <span class="pre">return</span> <span class="pre">``True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code> as appropriate.</p>
<p>Values not between 0 and 100 are treated as though they
were 0 or 100, whichever is nearer.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.AbstractEngine.roll_die">
<code class="descname">roll_die</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.roll_die"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.roll_die" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll a die with <code class="docutils literal notranslate"><span class="pre">d</span></code> faces. Return the result.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.DummyEntity">
<em class="property">class </em><code class="descclassname">LiSE.engine.</code><code class="descname">DummyEntity</code><span class="sig-paren">(</span><em>engine</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#DummyEntity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.DummyEntity" title="Permalink to this definition">¶</a></dt>
<dd><p>Something to use in place of a node or edge</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine">
<em class="property">class </em><code class="descclassname">LiSE.engine.</code><code class="descname">Engine</code><span class="sig-paren">(</span><em>worlddb</em>, <em>*</em>, <em>string='strings.json'</em>, <em>function='function.py'</em>, <em>method='method.py'</em>, <em>trigger='trigger.py'</em>, <em>prereq='prereq.py'</em>, <em>action='action.py'</em>, <em>connect_args={}</em>, <em>alchemy=False</em>, <em>commit_modulus=None</em>, <em>random_seed=None</em>, <em>logfun=None</em>, <em>validate=False</em>, <em>clear_code=False</em>, <em>clear_world=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine" title="Permalink to this definition">¶</a></dt>
<dd><p>LiSE, the Life Simulator Engine.</p>
<p>Each instance of LiSE maintains a connection to a database
representing the state of a simulated world. Simulation rules
within this world are described by lists of Python functions, some
of which make changes to the world.</p>
<p>The top-level data structure within LiSE is the character. Most
data within the world model is kept in some character or other;
these will quite frequently represent people, but can be readily
adapted to represent any kind of data that can be comfortably
described as a graph or a JSON object. Every change to a character
will be written to the database.</p>
<p>LiSE tracks history as a series of turns. In each turn, each
simulation rule is evaluated once for each of the simulated
entities it’s been applied to. World changes in a given turn are
remembered together, such that the whole world state can be
rewound: simply set the properties <code class="docutils literal notranslate"><span class="pre">branch</span></code> and <code class="docutils literal notranslate"><span class="pre">turn</span></code> back to
what they were just before the change you want to undo.</p>
<p>Properties:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">branch</span></code>: The fork of the timestream that we’re on.</li>
<li><code class="docutils literal notranslate"><span class="pre">turn</span></code>: Units of time that have passed since the sim started.</li>
<li><code class="docutils literal notranslate"><span class="pre">time</span></code>: <code class="docutils literal notranslate"><span class="pre">(branch,</span> <span class="pre">turn)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">tick</span></code>: A counter of how many changes have occurred this turn</li>
<li><code class="docutils literal notranslate"><span class="pre">character</span></code>: A mapping of <a class="reference internal" href="#LiSE.engine.Engine.Character" title="LiSE.engine.Engine.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a> objects by name.</li>
<li><code class="docutils literal notranslate"><span class="pre">rule</span></code>: A mapping of all rules that have been made.</li>
<li><code class="docutils literal notranslate"><span class="pre">rulebook</span></code>: A mapping of lists of rules. They are followed in
their order.  A whole rulebook full of rules may be assigned to
an entity at once.</li>
<li><code class="docutils literal notranslate"><span class="pre">trigger</span></code>: A mapping of functions that might trigger a rule.</li>
<li><code class="docutils literal notranslate"><span class="pre">prereq</span></code>: A mapping of functions a rule might require to return
<code class="docutils literal notranslate"><span class="pre">True</span></code> for it to run.</li>
<li><code class="docutils literal notranslate"><span class="pre">action</span></code>: A mapping of functions that might manipulate the world
state as a result of a rule running.</li>
<li><code class="docutils literal notranslate"><span class="pre">function</span></code>: A mapping of generic functions.</li>
<li><code class="docutils literal notranslate"><span class="pre">string</span></code>: A mapping of strings, probably shown to the player
at some point.</li>
<li><code class="docutils literal notranslate"><span class="pre">eternal</span></code>: Mapping of arbitrary serializable objects. It isn’t
sensitive to sim-time. A good place to keep game settings.</li>
<li><code class="docutils literal notranslate"><span class="pre">universal</span></code>: Another mapping of arbitrary serializable
objects, but this one <em>is</em> sensitive to sim-time. Each turn, the
state of the randomizer is saved here under the key
<code class="docutils literal notranslate"><span class="pre">'rando_state'</span></code>.</li>
</ul>
<dl class="class">
<dt id="LiSE.engine.Engine.Character">
<em class="property">class </em><code class="descname">Character</code><span class="sig-paren">(</span><em>engine</em>, <em>name</em>, <em>data=None</em>, <em>*</em>, <em>init_rulebooks=True</em>, <em>**attr</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character" title="Permalink to this definition">¶</a></dt>
<dd><p>A graph that follows game rules and has a containment hierarchy.</p>
<p>Nodes in a Character are subcategorized into Things and
Places. Things have locations, and those locations may be Places
or other Things.</p>
<p>Characters may have avatars in other Characters. These are just
nodes. You can apply rules to a Character’s avatars, and thus to
any collection of nodes you want, perhaps in many different
Characters. But you may want a Character to have exactly one
avatar, representing their location in physical space – the
Character named ‘physical’. So when a Character has only one
avatar, you can treat the <code class="docutils literal notranslate"><span class="pre">avatar</span></code> property as an alias of the
avatar.</p>
<dl class="class">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping">
<em class="property">class </em><code class="descname">AvatarGraphMapping</code><span class="sig-paren">(</span><em>char</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of other characters in which one has an avatar.</p>
<p>Maps to a mapping of the avatars themselves, unless there’s
only one other character you have avatars in, in which case
this maps to those.</p>
<p>If you have only one avatar anywhere, you can pretend this
is that entity.</p>
<dl class="class">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.CharacterAvatarMapping">
<em class="property">class </em><code class="descname">CharacterAvatarMapping</code><span class="sig-paren">(</span><em>outer</em>, <em>graphn</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.CharacterAvatarMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of avatars of one Character in another Character.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.node">
<code class="descname">node</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.node" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have avatars in only one graph, return a map of them.</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.only">
<code class="descname">only</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.only" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have only one avatar, return it.</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Character.PlaceMapping">
<em class="property">class </em><code class="descname">PlaceMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> objects that are in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></p>
<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.PlaceMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PlaceMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.PlaceMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PlaceMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Character.PortalPredecessorsMapping">
<em class="property">class </em><code class="descname">PortalPredecessorsMapping</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one incoming edge.</p>
<p>Maps to another mapping keyed by the origin nodes, which maps to
Portal objects.</p>
<dl class="class">
<dt id="LiSE.engine.Engine.Character.PortalPredecessorsMapping.Predecessors">
<em class="property">class </em><code class="descname">Predecessors</code><span class="sig-paren">(</span><em>container</em>, <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalPredecessorsMapping.Predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of possible origins from some destination.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping">
<em class="property">class </em><code class="descname">PortalSuccessorsMapping</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one outgoing edge.</p>
<p>Maps them to another mapping, keyed by the destination nodes,
which maps to Portal objects.</p>
<dl class="class">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors">
<em class="property">class </em><code class="descname">Successors</code><span class="sig-paren">(</span><em>container</em>, <em>orig</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for possible destinations from some node.</p>
<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.send">
<em class="property">static </em><code class="descname">send</code><span class="sig-paren">(</span><em>self</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Call all listeners to <code class="docutils literal notranslate"><span class="pre">dest</span></code> and to my <code class="docutils literal notranslate"><span class="pre">orig</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Character.ThingMapping">
<em class="property">class </em><code class="descname">ThingMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> objects that are in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></p>
<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.ThingMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.ThingMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping">
<em class="property">class </em><code class="descname">ThingPlaceMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>GraphNodeMapping but for Place and Thing</p>
<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.add_avatar">
<code class="descname">add_avatar</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>Start keeping track of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> in a
different <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.add_places_from">
<code class="descname">add_places_from</code><span class="sig-paren">(</span><em>seq</em>, <em>**attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_places_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a series of place names and add the lot.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.add_portal">
<code class="descname">add_portal</code><span class="sig-paren">(</span><em>origin</em>, <em>destination</em>, <em>symmetrical=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the origin to the destination with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>Keyword arguments are the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s
attributes. Exception: if keyword <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> == <code class="docutils literal notranslate"><span class="pre">True</span></code>,
a mirror-<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> will be placed in the opposite
direction between the same nodes. It will always appear to
have the placed <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats, and any change to the
mirror <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats will affect the placed
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.add_portals_from">
<code class="descname">add_portals_from</code><span class="sig-paren">(</span><em>seq</em>, <em>symmetrical=False</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_portals_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a sequence of (origin, destination) pairs and make a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> for each.</p>
<p>Actually, triples are acceptable too, in which case the third
item is a dictionary of stats for the new <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>If optional argument <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, all
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> instances will have a mirror portal going
in the opposite direction, which will always have the same
stats.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.add_thing">
<code class="descname">add_thing</code><span class="sig-paren">(</span><em>name</em>, <em>location</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Thing, set its location,
and set its initial attributes from the keyword arguments (if
any).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.adj_cls">
<code class="descname">adj_cls</code><a class="headerlink" href="#LiSE.engine.Engine.Character.adj_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalSuccessorsMapping</span></code></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.avatars">
<code class="descname">avatars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.avatars" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all my avatars, regardless of what character they are
in.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.del_avatar">
<code class="descname">del_avatar</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.del_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>This is no longer my avatar, though it still exists on its own.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.node_map_cls">
<code class="descname">node_map_cls</code><a class="headerlink" href="#LiSE.engine.Engine.Character.node_map_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Character.ThingPlaceMapping</span></code></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.place2thing">
<code class="descname">place2thing</code><span class="sig-paren">(</span><em>name</em>, <em>location</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.place2thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a Place into a Thing with the given location.</p>
<p>It will keep all its attached Portals.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.portals">
<code class="descname">portals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all portals.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Character.pred_cls">
<code class="descname">pred_cls</code><a class="headerlink" href="#LiSE.engine.Engine.Character.pred_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalPredecessorsMapping</span></code></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Character.thing2place">
<code class="descname">thing2place</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.thing2place" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset a Thing’s location, and thus turn it into a Place.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Place">
<em class="property">class </em><code class="descname">Place</code><span class="sig-paren">(</span><em>character</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Place" title="Permalink to this definition">¶</a></dt>
<dd><p>The kind of node where a thing might ultimately be located.</p>
<dl class="attribute">
<dt id="LiSE.engine.Engine.Place.db">
<code class="descname">db</code><a class="headerlink" href="#LiSE.engine.Engine.Place.db" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Place.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Place.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from the world model immediately.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Portal">
<em class="property">class </em><code class="descname">Portal</code><span class="sig-paren">(</span><em>graph</em>, <em>orig</em>, <em>dest</em>, <em>idx=0</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection between two Places that Things may travel along.</p>
<p>Portals are one-way, but you can make one appear two-way by
setting the <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> key to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
eg. <code class="docutils literal notranslate"><span class="pre">character.add_portal(orig,</span> <span class="pre">dest,</span> <span class="pre">symmetrical=True)</span></code>.
The portal going the other way will appear to have all the
stats of this one, and attempting to set a stat on it will
set it here instead.</p>
<dl class="attribute">
<dt id="LiSE.engine.Engine.Portal.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Portal.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>.</p>
<p>For symmetry with <code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> and :class`Place`.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Portal.destination">
<code class="descname">destination</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.destination" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Place object at which I end</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Portal.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Portal.origin">
<code class="descname">origin</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Place object that is where I begin</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Portal.reciprocal">
<code class="descname">reciprocal</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>If there’s another Portal connecting the same origin and
destination that I do, but going the opposite way, return
it. Else raise KeyError.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Portal.unwrap">
<code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a dict, and unwrap any wrapper objects in me.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Portal.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Works like regular update, but only actually updates when the new
value and the old value differ. This is necessary to prevent
certain infinite loops.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.QueryEngine">
<em class="property">class </em><code class="descname">QueryEngine</code><span class="sig-paren">(</span><em>dbstring</em>, <em>connect_args</em>, <em>alchemy</em>, <em>pack=None</em>, <em>unpack=None</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="LiSE.engine.Engine.QueryEngine.exist_edge">
<code class="descname">exist_edge</code><span class="sig-paren">(</span><em>character</em>, <em>orig</em>, <em>dest</em>, <em>idx</em>, <em>branch</em>, <em>turn</em>, <em>tick</em>, <em>extant=None</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.exist_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare whether or not this edge exists.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.QueryEngine.exist_node">
<code class="descname">exist_node</code><span class="sig-paren">(</span><em>character</em>, <em>node</em>, <em>branch</em>, <em>turn</em>, <em>tick</em>, <em>extant</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.exist_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the node exists or doesn’t.</p>
<p>Inserts a new record or updates an old one, as needed.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.QueryEngine.initdb">
<code class="descname">initdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.initdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the database schema, both for allegedb and the special
extensions for LiSE</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.Engine.Thing">
<em class="property">class </em><code class="descname">Thing</code><span class="sig-paren">(</span><em>character</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing" title="Permalink to this definition">¶</a></dt>
<dd><p>The sort of item that has a particular location at any given time.</p>
<p>If a Thing is in a Place, it is standing still. If it is in a
Portal, it is moving through that Portal however fast it must in
order to arrive at the other end when it is scheduled to. If it is
in another Thing, then it is wherever that is, and moving the
same.</p>
<dl class="method">
<dt id="LiSE.engine.Engine.Thing.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset everything.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Thing.db">
<code class="descname">db</code><a class="headerlink" href="#LiSE.engine.Engine.Thing.db" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Thing.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of this, starting now.</p>
<p>Apart from deleting the node, this also informs all its users
that it doesn’t exist and therefore can’t be their avatar
anymore.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Thing.follow_path">
<code class="descname">follow_path</code><span class="sig-paren">(</span><em>path</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.follow_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to several <code class="xref py py-class docutils literal notranslate"><span class="pre">Place`s</span> <span class="pre">in</span> <span class="pre">succession,</span> <span class="pre">deciding</span> <span class="pre">how</span> <span class="pre">long</span> <span class="pre">to</span>
<span class="pre">spend</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">by</span> <span class="pre">consulting</span> <span class="pre">the</span> <span class="pre">``weight`</span></code> stat of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> connecting the one <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> to the next.</p>
<p>Return the total number of turns the travel will take. Raise
<code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code> if I can’t follow the whole path,
either because some of its nodes don’t exist, or because I’m
scheduled to be somewhere else.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Thing.go_to_place">
<code class="descname">go_to_place</code><span class="sig-paren">(</span><em>place</em>, <em>weight=''</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.go_to_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming I’m in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> that has a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> direct
to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, schedule myself to travel to the
given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, taking an amount of time indicated by
the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat on the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>, if given; else 1
turn.</p>
<p>Return the number of turns the travel will take.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.Thing.location">
<code class="descname">location</code><a class="headerlink" href="#LiSE.engine.Engine.Thing.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">Thing</span></code> or <code class="docutils literal notranslate"><span class="pre">Place</span></code> I’m in.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.Thing.travel_to">
<code class="descname">travel_to</code><span class="sig-paren">(</span><em>dest</em>, <em>weight=None</em>, <em>graph=None</em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.travel_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the shortest path to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> from where I am
now, and follow it.</p>
<p>If supplied, the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat of the :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Portal`s along
the path will be used in pathfinding, and for deciding how
long to stay in each Place along the way.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">graph</span></code> argument may be any NetworkX-style graph. It
will be used for pathfinding if supplied, otherwise I’ll use
my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>. In either case, however, I will attempt
to actually follow the path using my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>, which
might not be possible if the supplied <code class="docutils literal notranslate"><span class="pre">graph</span></code> and my
<code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code> are too different. If it’s not possible,
I’ll raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code>, whose <code class="docutils literal notranslate"><span class="pre">subpath</span></code>
attribute holds the part of the path that I <em>can</em> follow. To
make me follow it, pass it to my <code class="docutils literal notranslate"><span class="pre">follow_path</span></code> method.</p>
<p>Return value is the number of turns the travel will take.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.add_character">
<code class="descname">add_character</code><span class="sig-paren">(</span><em>name</em>, <em>data=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.add_character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.add_character" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new character.</p>
<p>You’ll be able to access it as a <a class="reference internal" href="#LiSE.engine.Engine.Character" title="LiSE.engine.Engine.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a> object by
looking up <code class="docutils literal notranslate"><span class="pre">name</span></code> in my <code class="docutils literal notranslate"><span class="pre">character</span></code> property.</p>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code>, if provided, should be a networkx-compatible graph
object. Your new character will be a copy of it.</p>
<p>Any keyword arguments will be set as stats of the new character.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.advance">
<code class="descname">advance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Follow the next rule if available.</p>
<p>If we’ve run out of rules, reset the rules iterator.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.char_cls">
<code class="descname">char_cls</code><a class="headerlink" href="#LiSE.engine.Engine.char_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.character.Character</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit changes and close the database.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.critical">
<code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.critical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.critical" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘critical’</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.debug"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘debug’</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.del_character">
<code class="descname">del_character</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.del_character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.del_character" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the Character from the database entirely.</p>
<p>This also deletes all its history. You’d better be sure.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.edge_cls">
<code class="descname">edge_cls</code><a class="headerlink" href="#LiSE.engine.Engine.edge_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘error’</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.get_delta">
<code class="descname">get_delta</code><span class="sig-paren">(</span><em>branch</em>, <em>turn_from</em>, <em>tick_from</em>, <em>turn_to</em>, <em>tick_to</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.get_delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.get_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary describing changes to the world.</p>
<p>Most keys will be character names, and their values will be dictionaries of
the character’s stats’ new values, with <code class="docutils literal notranslate"><span class="pre">None</span></code> for deleted keys. Characters’
dictionaries have special keys ‘nodes’ and ‘edges’ which contain booleans indicating
whether the node or edge exists at the moment, and ‘node_val’ and ‘edge_val’ for
the stats of those entities. For edges (also called portals) these dictionaries
are two layers deep, keyed first by the origin, then by the destination.</p>
<p>Characters also have special keys for the various rulebooks they have:</p>
<ul class="simple">
<li>‘character_rulebook’</li>
<li>‘avatar_rulebook’</li>
<li>‘character_thing_rulebook’</li>
<li>‘character_place_rulebook’</li>
<li>‘character_portal_rulebook’</li>
</ul>
<p>And each node and edge may have a ‘rulebook’ stat of its own. If a node is a thing,
it gets a ‘location’; when the ‘location’ is deleted,
that means it’s back to being a place.</p>
<p>Keys at the top level that are not character names:</p>
<ul class="simple">
<li>‘rulebooks’, a dictionary keyed by the name of each changed rulebook, the value</li>
</ul>
<p>being a list of rule names
* ‘rules’, a dictionary keyed by the name of each changed rule, containing any
of the lists ‘triggers’, ‘prereqs’, and ‘actions’</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.get_turn_delta">
<code class="descname">get_turn_delta</code><span class="sig-paren">(</span><em>branch=None</em>, <em>turn=None</em>, <em>tick=None</em>, <em>start_tick=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.get_turn_delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.get_turn_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary describing changes to the world within a given turn</p>
<p>Defaults to the present turn, and stops at the present tick unless specified.</p>
<p>See the documentation for <code class="docutils literal notranslate"><span class="pre">get_delta</span></code> for a detailed description of the
delta format.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.info">
<code class="descname">info</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘info’</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.new_character">
<code class="descname">new_character</code><span class="sig-paren">(</span><em>name</em>, <em>data=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.new_character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.new_character" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new <a class="reference internal" href="#LiSE.engine.Engine.Character" title="LiSE.engine.Engine.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.node_cls">
<code class="descname">node_cls</code><a class="headerlink" href="#LiSE.engine.Engine.node_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.place.Place" title="LiSE.place.Place"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.place.Place</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.place_cls">
<code class="descname">place_cls</code><a class="headerlink" href="#LiSE.engine.Engine.place_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.place.Place" title="LiSE.place.Place"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.place.Place</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.portal_cls">
<code class="descname">portal_cls</code><a class="headerlink" href="#LiSE.engine.Engine.portal_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.query_engine_cls">
<code class="descname">query_engine_cls</code><a class="headerlink" href="#LiSE.engine.Engine.query_engine_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.query.QueryEngine" title="LiSE.query.QueryEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.query.QueryEngine</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.engine.Engine.thing_cls">
<code class="descname">thing_cls</code><a class="headerlink" href="#LiSE.engine.Engine.thing_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.thing.Thing" title="LiSE.thing.Thing"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.thing.Thing</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.engine.Engine.warning">
<code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.warning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘warning’</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.engine.FinalRule">
<em class="property">class </em><code class="descclassname">LiSE.engine.</code><code class="descname">FinalRule</code><a class="reference internal" href="../_modules/LiSE/engine.html#FinalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.FinalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>A singleton sentinel for the rule iterator</p>
</dd></dl>

<dl class="exception">
<dt id="LiSE.engine.InnerStopIteration">
<em class="property">exception </em><code class="descclassname">LiSE.engine.</code><code class="descname">InnerStopIteration</code><a class="reference internal" href="../_modules/LiSE/engine.html#InnerStopIteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.InnerStopIteration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LiSE.engine.NextTurn">
<em class="property">class </em><code class="descclassname">LiSE.engine.</code><code class="descname">NextTurn</code><span class="sig-paren">(</span><em>engine</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#NextTurn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.NextTurn" title="Permalink to this definition">¶</a></dt>
<dd><p>Make time move forward in the simulation.</p>
<p>Calls <code class="docutils literal notranslate"><span class="pre">advance</span></code> repeatedly, returning a list of the rules’ return values.</p>
<p>I am also a <code class="docutils literal notranslate"><span class="pre">Signal</span></code>, so you can register functions to be
called when the simulation runs. Pass them to my <code class="docutils literal notranslate"><span class="pre">connect</span></code>
method.</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.character">
<span id="character"></span><h2>character<a class="headerlink" href="#module-LiSE.character" title="Permalink to this headline">¶</a></h2>
<p>The top level of the LiSE world model, the Character.</p>
<p>Based on NetworkX DiGraph objects with various additions and
conveniences.</p>
<p>A Character is a graph that follows rules. Its rules may be assigned
to run on only some portion of it: just edges (called Portals), just
nodes, or just nodes of the kind that have a location in another node
(called Places and Things, respectively). Each Character has a
<code class="docutils literal notranslate"><span class="pre">stat</span></code> property that acts very much like a dictionary, in which you
can store game-relevant data for the rules to use.</p>
<p>You can designate some nodes in one Character as avatars of another,
and then assign a rule to run on all of a Character’s avatars. This is
useful for the common case where someone in your game has a location
in the physical world (here, a Character, called ‘physical’) but also
has a behavior flowchart, or a skill tree, that isn’t part of the
physical world. In that case the flowchart is the person’s Character,
and their node in the physical world is an avatar of it.</p>
<dl class="class">
<dt id="LiSE.character.AbstractCharacter">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">AbstractCharacter</code><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter" title="Permalink to this definition">¶</a></dt>
<dd><p>The Character API, with all requisite mappings and graph generators.</p>
<p>Mappings resemble those of a NetworkX digraph:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">thing</span></code> and <code class="docutils literal notranslate"><span class="pre">place</span></code> are subsets of <code class="docutils literal notranslate"><span class="pre">node</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">edge</span></code>, <code class="docutils literal notranslate"><span class="pre">adj</span></code>, and <code class="docutils literal notranslate"><span class="pre">succ</span></code> are aliases of <code class="docutils literal notranslate"><span class="pre">portal</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code> is an alias to <code class="docutils literal notranslate"><span class="pre">preportal</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">stat</span></code> is a dict-like mapping of data that changes over game-time,</li>
</ul>
<p>to be used in place of graph attributes</p>
<dl class="method">
<dt id="LiSE.character.AbstractCharacter.become">
<code class="descname">become</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.become"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.become" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase all my nodes and edges. Replace them with a copy of the graph
provided.</p>
<p>Return myself.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.copy_from">
<code class="descname">copy_from</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.copy_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.copy_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all nodes and edges from the given graph into this.</p>
<p>Return myself.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.cull_edges">
<code class="descname">cull_edges</code><span class="sig-paren">(</span><em>stat</em>, <em>threshold=0.5</em>, <em>comparator=&lt;built-in function ge&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.cull_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.cull_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete edges whose stat &gt;= <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (default 0.5).</p>
<p>Optional argument <code class="docutils literal notranslate"><span class="pre">comparator</span></code> will replace &gt;= as the test
for whether to cull. You can use the name of a stored function.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.cull_nodes">
<code class="descname">cull_nodes</code><span class="sig-paren">(</span><em>stat</em>, <em>threshold=0.5</em>, <em>comparator=&lt;built-in function ge&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.cull_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.cull_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete nodes whose stat &gt;= <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (default 0.5).</p>
<p>Optional argument <code class="docutils literal notranslate"><span class="pre">comparator</span></code> will replace &gt;= as the test
for whether to cull. You can use the name of a stored function.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.cull_portals">
<code class="descname">cull_portals</code><span class="sig-paren">(</span><em>stat</em>, <em>threshold=0.5</em>, <em>comparator=&lt;built-in function ge&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.cull_portals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.cull_portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete portals whose stat &gt;= <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (default 0.5).</p>
<p>Optional argument <code class="docutils literal notranslate"><span class="pre">comparator</span></code> will replace &gt;= as the test
for whether to cull. You can use the name of a stored function.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.do">
<code class="descname">do</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.do"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.do" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the function to myself, and return myself.</p>
<p>Look up the function in the database if needed. Pass it any
arguments given, keyword or positional.</p>
<p>Useful chiefly when chaining.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.AbstractCharacter.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.AbstractCharacter.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.grid_2d_8graph">
<code class="descname">grid_2d_8graph</code><span class="sig-paren">(</span><em>m</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.grid_2d_8graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.grid_2d_8graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a 2d graph that’s connected 8 ways, enabling diagonal movement</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.AbstractCharacter.perlin">
<code class="descname">perlin</code><span class="sig-paren">(</span><em>stat='perlin'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.perlin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.perlin" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Perlin noise to my nodes, and return myself.</p>
<p>I’ll try to use the name of the node as its spatial position
for this purpose, or use its stats ‘x’, ‘y’, and ‘z’, or skip
the node if neither are available. z is assumed 0 if not
provided for a node.</p>
<p>Result will be stored in a node stat named ‘perlin’ by default.
Supply the name of another stat to use it instead.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.AbstractCharacter.stat">
<code class="descname">stat</code><a class="headerlink" href="#LiSE.character.AbstractCharacter.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.CharRuleMapping">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">CharRuleMapping</code><span class="sig-paren">(</span><em>character</em>, <em>rulebook</em>, <em>booktyp</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#CharRuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.CharRuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps one of a character’s rulebooks so you can get its rules by name.</p>
<p>You can access the rules in this either dictionary-style or as
attributes. This is for convenience if you want to get at a rule’s
decorators, eg. to add an Action to the rule.</p>
<p>Using this as a decorator will create a new rule, named for the
decorated function, and using the decorated function as the
initial Action.</p>
<p>Using this like a dictionary will let you create new rules,
appending them onto the underlying <code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code>; replace one
rule with another, where the new one will have the same index in
the <code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code> as the old one; and activate or deactivate
rules. The name of a rule may be used in place of the actual rule,
so long as the rule already exists.</p>
<p>You can also set a rule active or inactive by setting it to
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, respectively. Inactive rules are still in
the rulebook, but won’t be followed.</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.character.Character">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">Character</code><span class="sig-paren">(</span><em>engine</em>, <em>name</em>, <em>data=None</em>, <em>*</em>, <em>init_rulebooks=True</em>, <em>**attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character" title="Permalink to this definition">¶</a></dt>
<dd><p>A graph that follows game rules and has a containment hierarchy.</p>
<p>Nodes in a Character are subcategorized into Things and
Places. Things have locations, and those locations may be Places
or other Things.</p>
<p>Characters may have avatars in other Characters. These are just
nodes. You can apply rules to a Character’s avatars, and thus to
any collection of nodes you want, perhaps in many different
Characters. But you may want a Character to have exactly one
avatar, representing their location in physical space – the
Character named ‘physical’. So when a Character has only one
avatar, you can treat the <code class="docutils literal notranslate"><span class="pre">avatar</span></code> property as an alias of the
avatar.</p>
<dl class="class">
<dt id="LiSE.character.Character.AvatarGraphMapping">
<em class="property">class </em><code class="descname">AvatarGraphMapping</code><span class="sig-paren">(</span><em>char</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.AvatarGraphMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of other characters in which one has an avatar.</p>
<p>Maps to a mapping of the avatars themselves, unless there’s
only one other character you have avatars in, in which case
this maps to those.</p>
<p>If you have only one avatar anywhere, you can pretend this
is that entity.</p>
<dl class="class">
<dt id="LiSE.character.Character.AvatarGraphMapping.CharacterAvatarMapping">
<em class="property">class </em><code class="descname">CharacterAvatarMapping</code><span class="sig-paren">(</span><em>outer</em>, <em>graphn</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.AvatarGraphMapping.CharacterAvatarMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.CharacterAvatarMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of avatars of one Character in another Character.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.AvatarGraphMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.AvatarGraphMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.AvatarGraphMapping.node">
<code class="descname">node</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.node" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have avatars in only one graph, return a map of them.</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.AvatarGraphMapping.only">
<code class="descname">only</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.only" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have only one avatar, return it.</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Character.PlaceMapping">
<em class="property">class </em><code class="descname">PlaceMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PlaceMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> objects that are in a <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a></p>
<dl class="attribute">
<dt id="LiSE.character.Character.PlaceMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Character.PlaceMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.PlaceMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.character.Character.PlaceMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Character.PortalPredecessorsMapping">
<em class="property">class </em><code class="descname">PortalPredecessorsMapping</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalPredecessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one incoming edge.</p>
<p>Maps to another mapping keyed by the origin nodes, which maps to
Portal objects.</p>
<dl class="class">
<dt id="LiSE.character.Character.PortalPredecessorsMapping.Predecessors">
<em class="property">class </em><code class="descname">Predecessors</code><span class="sig-paren">(</span><em>container</em>, <em>dest</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalPredecessorsMapping.Predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalPredecessorsMapping.Predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of possible origins from some destination.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Character.PortalSuccessorsMapping">
<em class="property">class </em><code class="descname">PortalSuccessorsMapping</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one outgoing edge.</p>
<p>Maps them to another mapping, keyed by the destination nodes,
which maps to Portal objects.</p>
<dl class="class">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors">
<em class="property">class </em><code class="descname">Successors</code><span class="sig-paren">(</span><em>container</em>, <em>orig</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping.Successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for possible destinations from some node.</p>
<dl class="attribute">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors.send">
<em class="property">static </em><code class="descname">send</code><span class="sig-paren">(</span><em>self</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping.Successors.send"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Call all listeners to <code class="docutils literal notranslate"><span class="pre">dest</span></code> and to my <code class="docutils literal notranslate"><span class="pre">orig</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Character.ThingMapping">
<em class="property">class </em><code class="descname">ThingMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.ThingMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.ThingMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> objects that are in a <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a></p>
<dl class="attribute">
<dt id="LiSE.character.Character.ThingMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Character.ThingMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.ThingMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.character.Character.ThingMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Character.ThingPlaceMapping">
<em class="property">class </em><code class="descname">ThingPlaceMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.ThingPlaceMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>GraphNodeMapping but for Place and Thing</p>
<dl class="attribute">
<dt id="LiSE.character.Character.ThingPlaceMapping.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.ThingPlaceMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.ThingPlaceMapping.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.add_avatar">
<code class="descname">add_avatar</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_avatar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>Start keeping track of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> in a
different <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.add_places_from">
<code class="descname">add_places_from</code><span class="sig-paren">(</span><em>seq</em>, <em>**attrs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_places_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_places_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a series of place names and add the lot.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.add_portal">
<code class="descname">add_portal</code><span class="sig-paren">(</span><em>origin</em>, <em>destination</em>, <em>symmetrical=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the origin to the destination with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>Keyword arguments are the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s
attributes. Exception: if keyword <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> == <code class="docutils literal notranslate"><span class="pre">True</span></code>,
a mirror-<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> will be placed in the opposite
direction between the same nodes. It will always appear to
have the placed <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats, and any change to the
mirror <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats will affect the placed
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.add_portals_from">
<code class="descname">add_portals_from</code><span class="sig-paren">(</span><em>seq</em>, <em>symmetrical=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_portals_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_portals_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a sequence of (origin, destination) pairs and make a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> for each.</p>
<p>Actually, triples are acceptable too, in which case the third
item is a dictionary of stats for the new <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>If optional argument <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, all
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> instances will have a mirror portal going
in the opposite direction, which will always have the same
stats.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.add_thing">
<code class="descname">add_thing</code><span class="sig-paren">(</span><em>name</em>, <em>location</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Thing, set its location,
and set its initial attributes from the keyword arguments (if
any).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.adj_cls">
<code class="descname">adj_cls</code><a class="headerlink" href="#LiSE.character.Character.adj_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character.PortalSuccessorsMapping" title="LiSE.character.Character.PortalSuccessorsMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalSuccessorsMapping</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.avatars">
<code class="descname">avatars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.avatars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.avatars" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all my avatars, regardless of what character they are
in.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.del_avatar">
<code class="descname">del_avatar</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.del_avatar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.del_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>This is no longer my avatar, though it still exists on its own.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.node_map_cls">
<code class="descname">node_map_cls</code><a class="headerlink" href="#LiSE.character.Character.node_map_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character.ThingPlaceMapping" title="LiSE.character.Character.ThingPlaceMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character.ThingPlaceMapping</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.place2thing">
<code class="descname">place2thing</code><span class="sig-paren">(</span><em>name</em>, <em>location</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.place2thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.place2thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a Place into a Thing with the given location.</p>
<p>It will keep all its attached Portals.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.portals">
<code class="descname">portals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.portals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all portals.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Character.pred_cls">
<code class="descname">pred_cls</code><a class="headerlink" href="#LiSE.character.Character.pred_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character.PortalPredecessorsMapping" title="LiSE.character.Character.PortalPredecessorsMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalPredecessorsMapping</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Character.thing2place">
<code class="descname">thing2place</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.thing2place"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.thing2place" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset a Thing’s location, and thus turn it into a Place.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.CharacterSense">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">CharacterSense</code><span class="sig-paren">(</span><em>container</em>, <em>sensename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#CharacterSense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.CharacterSense" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for when you’ve selected a sense for a character to use
but haven’t yet specified what character to look at</p>
<dl class="attribute">
<dt id="LiSE.character.CharacterSense.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.CharacterSense.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.CharacterSense.func">
<code class="descname">func</code><a class="headerlink" href="#LiSE.character.CharacterSense.func" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function most recently associated with this sense.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.CharacterSense.observer">
<code class="descname">observer</code><a class="headerlink" href="#LiSE.character.CharacterSense.observer" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.CharacterSenseMapping">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">CharacterSenseMapping</code><span class="sig-paren">(</span><em>character</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#CharacterSenseMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.CharacterSenseMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to view other Characters as seen by one, via a particular sense.</p>
<dl class="attribute">
<dt id="LiSE.character.CharacterSenseMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.CharacterSenseMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Facade">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">Facade</code><span class="sig-paren">(</span><em>character=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="LiSE.character.Facade.PlaceMapping">
<em class="property">class </em><code class="descname">PlaceMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.PlaceMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.PlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="LiSE.character.Facade.PlaceMapping.facadecls">
<code class="descname">facadecls</code><a class="headerlink" href="#LiSE.character.Facade.PlaceMapping.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePlace" title="LiSE.character.FacadePlace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePlace</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Facade.PlaceMapping.innercls">
<code class="descname">innercls</code><a class="headerlink" href="#LiSE.character.Facade.PlaceMapping.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.place.Place" title="LiSE.place.Place"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.place.Place</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Facade.PortalPredecessorsMapping">
<em class="property">class </em><code class="descname">PortalPredecessorsMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.PortalPredecessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.PortalPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="LiSE.character.Facade.PortalPredecessorsMapping.cls">
<code class="descname">cls</code><a class="headerlink" href="#LiSE.character.Facade.PortalPredecessorsMapping.cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortalPredecessors" title="LiSE.character.FacadePortalPredecessors"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortalPredecessors</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Facade.PortalSuccessorsMapping">
<em class="property">class </em><code class="descname">PortalSuccessorsMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.PortalSuccessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.PortalSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="LiSE.character.Facade.PortalSuccessorsMapping.cls">
<code class="descname">cls</code><a class="headerlink" href="#LiSE.character.Facade.PortalSuccessorsMapping.cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortalSuccessors" title="LiSE.character.FacadePortalSuccessors"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortalSuccessors</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.Facade.StatMapping">
<em class="property">class </em><code class="descname">StatMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.StatMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.StatMapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LiSE.character.Facade.ThingMapping">
<em class="property">class </em><code class="descname">ThingMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.ThingMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.ThingMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="LiSE.character.Facade.ThingMapping.facadecls">
<code class="descname">facadecls</code><a class="headerlink" href="#LiSE.character.Facade.ThingMapping.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadeThing" title="LiSE.character.FacadeThing"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadeThing</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Facade.ThingMapping.innercls">
<code class="descname">innercls</code><a class="headerlink" href="#LiSE.character.Facade.ThingMapping.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.thing.Thing" title="LiSE.thing.Thing"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.thing.Thing</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="LiSE.character.Facade.add_edge">
<code class="descname">add_edge</code><span class="sig-paren">(</span><em>orig</em>, <em>dest</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.add_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge between u and v.</p>
<p>The nodes u and v will be automatically added if they are
not already in the graph.</p>
<p>Edge attributes can be specified with keywords or by directly
accessing the edge’s attribute dictionary. See examples below.</p>
<dl class="docutils">
<dt>u, v <span class="classifier-delimiter">:</span> <span class="classifier">nodes</span></dt>
<dd>Nodes can be, for example, strings or numbers.
Nodes must be hashable (and not None) Python objects.</dd>
<dt>attr <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments, optional</span></dt>
<dd>Edge data (or labels or objects) can be assigned using
keyword arguments.</dd>
</dl>
<p>add_edges_from : add a collection of edges</p>
<p>Adding an edge that already exists updates the edge data.</p>
<p>Many NetworkX algorithms designed for weighted graphs use
an edge attribute (by default <cite>weight</cite>) to hold a numerical value.</p>
<p>The following all add the edge e=(1, 2) to graph G:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>           <span class="c1"># explicit two-node form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>             <span class="c1"># single edge as tuple of two nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span> <span class="p">)</span> <span class="c1"># add edges from iterable container</span>
</pre></div>
</div>
<p>Associate data to edges using keywords:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">342.7</span><span class="p">)</span>
</pre></div>
</div>
<p>For non-string attribute keys, use subscript notation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LiSE.character.Facade.add_node">
<code class="descname">add_node</code><span class="sig-paren">(</span><em>name</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p>
<dl class="docutils">
<dt>node_for_adding <span class="classifier-delimiter">:</span> <span class="classifier">node</span></dt>
<dd>A node can be any hashable Python object except None.</dd>
<dt>attr <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments, optional</span></dt>
<dd>Set or change node attributes using key=value.</dd>
</dl>
<p>add_nodes_from</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Use keywords set/change node attributes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">UTM</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;13S&#39;</span><span class="p">,</span> <span class="mi">382871</span><span class="p">,</span> <span class="mi">3972649</span><span class="p">))</span>
</pre></div>
</div>
<p>A hashable object is one that can be used as a key in a Python
dictionary. This includes strings, numbers, tuples of strings
and numbers, etc.</p>
<p>On many platforms hashable items also include mutables such as
NetworkX Graphs, though one should be careful that the hash
doesn’t change on mutables.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.Facade.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.Facade.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadeEntity">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadeEntity</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeEntity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeEntity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadeEntityMapping">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadeEntityMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeEntityMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeEntityMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping that contains entities in a Facade.</p>
<p>All the entities are of the same type, <code class="docutils literal notranslate"><span class="pre">facadecls</span></code>, possibly
being distorted views of entities of the type <code class="docutils literal notranslate"><span class="pre">innercls</span></code>.</p>
<dl class="attribute">
<dt id="LiSE.character.FacadeEntityMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.FacadeEntityMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadePlace">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadePlace</code><span class="sig-paren">(</span><em>mapping</em>, <em>real_or_name</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePlace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePlace" title="Permalink to this definition">¶</a></dt>
<dd><p>Lightweight analogue of Place for Facade use.</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadePortal">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadePortal</code><span class="sig-paren">(</span><em>mapping</em>, <em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortal" title="Permalink to this definition">¶</a></dt>
<dd><p>Lightweight analogue of Portal for Facade use.</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadePortalMapping">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadePortalMapping</code><span class="sig-paren">(</span><em>facade</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortalMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortalMapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadePortalPredecessors">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadePortalPredecessors</code><span class="sig-paren">(</span><em>facade</em>, <em>destname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortalPredecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortalPredecessors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="LiSE.character.FacadePortalPredecessors.facadecls">
<code class="descname">facadecls</code><a class="headerlink" href="#LiSE.character.FacadePortalPredecessors.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortal" title="LiSE.character.FacadePortal"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortal</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.FacadePortalPredecessors.innercls">
<code class="descname">innercls</code><a class="headerlink" href="#LiSE.character.FacadePortalPredecessors.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadePortalSuccessors">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadePortalSuccessors</code><span class="sig-paren">(</span><em>facade</em>, <em>origname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortalSuccessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortalSuccessors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="LiSE.character.FacadePortalSuccessors.facadecls">
<code class="descname">facadecls</code><a class="headerlink" href="#LiSE.character.FacadePortalSuccessors.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortal" title="LiSE.character.FacadePortal"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortal</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.character.FacadePortalSuccessors.innercls">
<code class="descname">innercls</code><a class="headerlink" href="#LiSE.character.FacadePortalSuccessors.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.character.FacadeThing">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">FacadeThing</code><span class="sig-paren">(</span><em>mapping</em>, <em>real_or_name</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeThing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeThing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LiSE.character.RuleFollower">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">RuleFollower</code><a class="reference internal" href="../_modules/LiSE/character.html#RuleFollower"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.RuleFollower" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixin class. Has a rulebook, which you can get a RuleMapping into.</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.character.SenseFuncWrap">
<em class="property">class </em><code class="descclassname">LiSE.character.</code><code class="descname">SenseFuncWrap</code><span class="sig-paren">(</span><em>character</em>, <em>fun</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#SenseFuncWrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.SenseFuncWrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for a sense function that looks it up in the code store if
provided with its name, and prefills the first two arguments.</p>
<dl class="attribute">
<dt id="LiSE.character.SenseFuncWrap.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.character.SenseFuncWrap.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.node">
<span id="node"></span><h2>node<a class="headerlink" href="#module-LiSE.node" title="Permalink to this headline">¶</a></h2>
<p>A base class for nodes that can be in a character.</p>
<p>Every actual node that you’re meant to use will be a place or
thing. This module is for what they have in common.</p>
<dl class="class">
<dt id="LiSE.node.Node">
<em class="property">class </em><code class="descclassname">LiSE.node.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>character</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>The fundamental graph component, which edges (in LiSE, “portals”)
go between.</p>
<p>Every LiSE node is either a thing or a place. They share in common
the abilities to follow rules; to be connected by portals; and to
contain things.</p>
<dl class="attribute">
<dt id="LiSE.node.Node.adj">
<code class="descname">adj</code><a class="headerlink" href="#LiSE.node.Node.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mapping of portals connecting this node to its neighbors.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.node.Node.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.node.Node.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete everything</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of this, starting now.</p>
<p>Apart from deleting the node, this also informs all its users
that it doesn’t exist and therefore can’t be their avatar
anymore.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.node.Node.edge">
<code class="descname">edge</code><a class="headerlink" href="#LiSE.node.Node.edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mapping of portals connecting this node to its neighbors.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.node.Node.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.node.Node.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.historical">
<code class="descname">historical</code><span class="sig-paren">(</span><em>stat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.historical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.historical" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the values that a stat has had in the past.</p>
<p>You can use the reference in comparisons to make a history
query, and execute the query by calling it, or passing it to
<code class="docutils literal notranslate"><span class="pre">self.engine.ticks_when</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.node.Node.name">
<code class="descname">name</code><a class="headerlink" href="#LiSE.node.Node.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.new_thing">
<code class="descname">new_thing</code><span class="sig-paren">(</span><em>name</em>, <em>**stats</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.new_thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.new_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new thing, located here, and return it.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.one_way">
<code class="descname">one_way</code><span class="sig-paren">(</span><em>other</em>, <em>**stats</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.one_way"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.one_way" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a portal from here to another node, and return it.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.one_way_portal">
<code class="descname">one_way_portal</code><span class="sig-paren">(</span><em>other</em>, <em>**stats</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.one_way_portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.one_way_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a portal from here to another node, and return it.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.path_exists">
<code class="descname">path_exists</code><span class="sig-paren">(</span><em>dest</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.path_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.path_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether there is a path leading from me to <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">weight</span></code>, only consider edges that have a stat by the
given name.</p>
<p>Raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if <code class="docutils literal notranslate"><span class="pre">dest</span></code> is not a node in my character
or the name of one.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.node.Node.portal">
<code class="descname">portal</code><a class="headerlink" href="#LiSE.node.Node.portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mapping of portals connecting this node to its neighbors.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.portals">
<code class="descname">portals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.portals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> objects that lead away from me</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.predecessors">
<code class="descname">predecessors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over nodes with edges leading here from there.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.preportals">
<code class="descname">preportals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.preportals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.preportals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> objects that lead to me</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.shortest_path">
<code class="descname">shortest_path</code><span class="sig-paren">(</span><em>dest</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.shortest_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of node names leading from me to <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<p>Raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if <code class="docutils literal notranslate"><span class="pre">dest</span></code> is not a node in my character
or the name of one.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.shortest_path_length">
<code class="descname">shortest_path_length</code><span class="sig-paren">(</span><em>dest</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.shortest_path_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the path from me to <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<p>Raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if <code class="docutils literal notranslate"><span class="pre">dest</span></code> is not a node in my character
or the name of one.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.node.Node.successor">
<code class="descname">successor</code><a class="headerlink" href="#LiSE.node.Node.successor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mapping of portals connecting this node to its neighbors.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over nodes with edges leading from here to there.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.two_way">
<code class="descname">two_way</code><span class="sig-paren">(</span><em>other</em>, <em>**stats</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.two_way"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.two_way" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect these nodes with a two-way portal and return it.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.node.Node.two_way_portal">
<code class="descname">two_way_portal</code><span class="sig-paren">(</span><em>other</em>, <em>**stats</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.two_way_portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.two_way_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect these nodes with a two-way portal and return it.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.node.RuleMapping">
<em class="property">class </em><code class="descclassname">LiSE.node.</code><code class="descname">RuleMapping</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#RuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.RuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Version of <a class="reference internal" href="#LiSE.rule.RuleMapping" title="LiSE.rule.RuleMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.rule.RuleMapping</span></code></a> that works more easily
with a node.</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.node.UserDescriptor">
<em class="property">class </em><code class="descclassname">LiSE.node.</code><code class="descname">UserDescriptor</code><a class="reference internal" href="../_modules/LiSE/node.html#UserDescriptor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.UserDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a node’s user if there’s only one</p>
<p>If there are many users, but one of them has the same name as this node, give that one.</p>
<p>Otherwise, raise AmbiguousUserError.</p>
<dl class="attribute">
<dt id="LiSE.node.UserDescriptor.usermapping">
<code class="descname">usermapping</code><a class="headerlink" href="#LiSE.node.UserDescriptor.usermapping" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.node.UserMapping" title="LiSE.node.UserMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserMapping</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.node.UserMapping">
<em class="property">class </em><code class="descclassname">LiSE.node.</code><code class="descname">UserMapping</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#UserMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.UserMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of the characters that have a particular node as an avatar.</p>
<p>Getting characters from here isn’t any better than getting them from
the engine direct, but with this you can do things like use the
.get() method to get a character if it’s a user and otherwise
get something else; or test whether the character’s name is in
the keys; and so on.</p>
<dl class="attribute">
<dt id="LiSE.node.UserMapping.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.node.UserMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.place">
<span id="place"></span><h2>place<a class="headerlink" href="#module-LiSE.place" title="Permalink to this headline">¶</a></h2>
<p>The type of node that is a location.</p>
<p>Though both things and places are nodes, things are obliged to be
located in another node. Places are not.</p>
<dl class="class">
<dt id="LiSE.place.Place">
<em class="property">class </em><code class="descclassname">LiSE.place.</code><code class="descname">Place</code><span class="sig-paren">(</span><em>character</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/place.html#Place"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.place.Place" title="Permalink to this definition">¶</a></dt>
<dd><p>The kind of node where a thing might ultimately be located.</p>
<dl class="attribute">
<dt id="LiSE.place.Place.db">
<code class="descname">db</code><a class="headerlink" href="#LiSE.place.Place.db" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.place.Place.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/place.html#Place.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.place.Place.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from the world model immediately.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.thing">
<span id="thing"></span><h2>thing<a class="headerlink" href="#module-LiSE.thing" title="Permalink to this headline">¶</a></h2>
<p>The sort of node that is ultimately located in a Place.</p>
<p>Things may be located in other Things as well, but eventually must be
recursively located in a Place.</p>
<p>There’s a subtle distinction between “location” and “containment”: a
Thing may be contained by a Portal, but cannot be located there –
only in one of the Portal’s endpoints. Things are both located in and
contained by Places, or possibly other Things.</p>
<dl class="class">
<dt id="LiSE.thing.Thing">
<em class="property">class </em><code class="descclassname">LiSE.thing.</code><code class="descname">Thing</code><span class="sig-paren">(</span><em>character</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing" title="Permalink to this definition">¶</a></dt>
<dd><p>The sort of item that has a particular location at any given time.</p>
<p>If a Thing is in a Place, it is standing still. If it is in a
Portal, it is moving through that Portal however fast it must in
order to arrive at the other end when it is scheduled to. If it is
in another Thing, then it is wherever that is, and moving the
same.</p>
<dl class="method">
<dt id="LiSE.thing.Thing.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset everything.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.thing.Thing.db">
<code class="descname">db</code><a class="headerlink" href="#LiSE.thing.Thing.db" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.thing.Thing.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of this, starting now.</p>
<p>Apart from deleting the node, this also informs all its users
that it doesn’t exist and therefore can’t be their avatar
anymore.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.thing.Thing.follow_path">
<code class="descname">follow_path</code><span class="sig-paren">(</span><em>path</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.follow_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.follow_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to several <code class="xref py py-class docutils literal notranslate"><span class="pre">Place`s</span> <span class="pre">in</span> <span class="pre">succession,</span> <span class="pre">deciding</span> <span class="pre">how</span> <span class="pre">long</span> <span class="pre">to</span>
<span class="pre">spend</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">by</span> <span class="pre">consulting</span> <span class="pre">the</span> <span class="pre">``weight`</span></code> stat of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> connecting the one <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> to the next.</p>
<p>Return the total number of turns the travel will take. Raise
<code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code> if I can’t follow the whole path,
either because some of its nodes don’t exist, or because I’m
scheduled to be somewhere else.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.thing.Thing.go_to_place">
<code class="descname">go_to_place</code><span class="sig-paren">(</span><em>place</em>, <em>weight=''</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.go_to_place"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.go_to_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming I’m in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> that has a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> direct
to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, schedule myself to travel to the
given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, taking an amount of time indicated by
the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat on the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>, if given; else 1
turn.</p>
<p>Return the number of turns the travel will take.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.thing.Thing.location">
<code class="descname">location</code><a class="headerlink" href="#LiSE.thing.Thing.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">Thing</span></code> or <code class="docutils literal notranslate"><span class="pre">Place</span></code> I’m in.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.thing.Thing.travel_to">
<code class="descname">travel_to</code><span class="sig-paren">(</span><em>dest</em>, <em>weight=None</em>, <em>graph=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.travel_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.travel_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the shortest path to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> from where I am
now, and follow it.</p>
<p>If supplied, the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat of the :class:<a href="#id3"><span class="problematic" id="id4">`</span></a>Portal`s along
the path will be used in pathfinding, and for deciding how
long to stay in each Place along the way.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">graph</span></code> argument may be any NetworkX-style graph. It
will be used for pathfinding if supplied, otherwise I’ll use
my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>. In either case, however, I will attempt
to actually follow the path using my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>, which
might not be possible if the supplied <code class="docutils literal notranslate"><span class="pre">graph</span></code> and my
<code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code> are too different. If it’s not possible,
I’ll raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code>, whose <code class="docutils literal notranslate"><span class="pre">subpath</span></code>
attribute holds the part of the path that I <em>can</em> follow. To
make me follow it, pass it to my <code class="docutils literal notranslate"><span class="pre">follow_path</span></code> method.</p>
<p>Return value is the number of turns the travel will take.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.portal">
<span id="portal"></span><h2>portal<a class="headerlink" href="#module-LiSE.portal" title="Permalink to this headline">¶</a></h2>
<p>Directed edges, as used by LiSE.</p>
<dl class="class">
<dt id="LiSE.portal.Portal">
<em class="property">class </em><code class="descclassname">LiSE.portal.</code><code class="descname">Portal</code><span class="sig-paren">(</span><em>graph</em>, <em>orig</em>, <em>dest</em>, <em>idx=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection between two Places that Things may travel along.</p>
<p>Portals are one-way, but you can make one appear two-way by
setting the <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> key to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
eg. <code class="docutils literal notranslate"><span class="pre">character.add_portal(orig,</span> <span class="pre">dest,</span> <span class="pre">symmetrical=True)</span></code>.
The portal going the other way will appear to have all the
stats of this one, and attempting to set a stat on it will
set it here instead.</p>
<dl class="attribute">
<dt id="LiSE.portal.Portal.character">
<code class="descname">character</code><a class="headerlink" href="#LiSE.portal.Portal.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.portal.Portal.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>.</p>
<p>For symmetry with <code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> and :class`Place`.</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.portal.Portal.destination">
<code class="descname">destination</code><a class="headerlink" href="#LiSE.portal.Portal.destination" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Place object at which I end</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.portal.Portal.engine">
<code class="descname">engine</code><a class="headerlink" href="#LiSE.portal.Portal.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.portal.Portal.origin">
<code class="descname">origin</code><a class="headerlink" href="#LiSE.portal.Portal.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Place object that is where I begin</p>
</dd></dl>

<dl class="attribute">
<dt id="LiSE.portal.Portal.reciprocal">
<code class="descname">reciprocal</code><a class="headerlink" href="#LiSE.portal.Portal.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>If there’s another Portal connecting the same origin and
destination that I do, but going the opposite way, return
it. Else raise KeyError.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.portal.Portal.unwrap">
<code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a dict, and unwrap any wrapper objects in me.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.portal.Portal.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Works like regular update, but only actually updates when the new
value and the old value differ. This is necessary to prevent
certain infinite loops.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.portal.RuleMapping">
<em class="property">class </em><code class="descclassname">LiSE.portal.</code><code class="descname">RuleMapping</code><span class="sig-paren">(</span><em>portal</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#RuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.RuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping to get rules followed by a portal.</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.rule">
<span id="rule"></span><h2>rule<a class="headerlink" href="#module-LiSE.rule" title="Permalink to this headline">¶</a></h2>
<p>The fundamental unit of game logic, the Rule, and structures to
store and organize them in.</p>
<p>A Rule is three lists of functions: triggers, prereqs, and actions.
The actions do something, anything that you need your game to do, but
probably making a specific change to the world model. The triggers and
prereqs between them specify when the action should occur: any of its
triggers can tell it to happen, but then any of its prereqs may stop it
from happening.</p>
<p>Rules are assembled into RuleBooks, essentially just lists of Rules
that can then be assigned to be followed by any game entity –
but each game entity has its own RuleBook by default, and you never really
need to change that.</p>
<dl class="class">
<dt id="LiSE.rule.ActionList">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">ActionList</code><span class="sig-paren">(</span><em>rule</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#ActionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.ActionList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of action functions for rules</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.rule.AllRuleBooks">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">AllRuleBooks</code><span class="sig-paren">(</span><em>engine</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#AllRuleBooks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.AllRuleBooks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="LiSE.rule.AllRules">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">AllRules</code><span class="sig-paren">(</span><em>engine</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#AllRules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.AllRules" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of every rule in the game.</p>
<p>You can use this as a decorator to make a rule and not assign it
to anything.</p>
<dl class="method">
<dt id="LiSE.rule.AllRules.new_empty">
<code class="descname">new_empty</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#AllRules.new_empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.AllRules.new_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a new rule with no actions or anything, and return it.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.rule.PrereqList">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">PrereqList</code><span class="sig-paren">(</span><em>rule</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#PrereqList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.PrereqList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of prereq functions for rules</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.rule.Rule">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">Rule</code><span class="sig-paren">(</span><em>engine</em>, <em>name</em>, <em>triggers=None</em>, <em>prereqs=None</em>, <em>actions=None</em>, <em>create=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of actions, being functions that enact some change on
the world, which will be called each tick if and only if all of
the prereqs return True, they being boolean functions that do not
change the world.</p>
<dl class="method">
<dt id="LiSE.rule.Rule.action">
<code class="descname">action</code><span class="sig-paren">(</span><em>fun</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.action"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.action" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to append the function to my actions list.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.Rule.always">
<code class="descname">always</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.always"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.always" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange to be triggered every tick, regardless of circumstance.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.Rule.duplicate">
<code class="descname">duplicate</code><span class="sig-paren">(</span><em>newname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.duplicate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new rule that’s just like this one, but under a new
name.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.Rule.prereq">
<code class="descname">prereq</code><span class="sig-paren">(</span><em>fun</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.prereq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.prereq" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to append the function to my prereqs list.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.Rule.trigger">
<code class="descname">trigger</code><span class="sig-paren">(</span><em>fun</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.trigger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to append the function to my triggers list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.rule.RuleBook">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">RuleBook</code><span class="sig-paren">(</span><em>engine</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleBook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleBook" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of rules to be followed for some Character, or a part of it
anyway.</p>
<dl class="method">
<dt id="LiSE.rule.RuleBook.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer -- return first index of value.<a class="reference internal" href="../_modules/LiSE/rule.html#RuleBook.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleBook.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises ValueError if the value is not present.</p>
<p>Supporting start and stop arguments is optional, but
recommended.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.RuleBook.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>i</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleBook.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleBook.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.rule.RuleFollower">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">RuleFollower</code><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFollower"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFollower" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for that which has a rulebook associated, which you can
get a <a class="reference internal" href="#LiSE.rule.RuleMapping" title="LiSE.rule.RuleMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleMapping</span></code></a> into</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.rule.RuleFuncList">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">RuleFuncList</code><span class="sig-paren">(</span><em>rule</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class for lists of functions like trigger, prereq, action</p>
<dl class="method">
<dt id="LiSE.rule.RuleFuncList.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList.append" title="Permalink to this definition">¶</a></dt>
<dd><p>S.append(value) – append value to the end of the sequence</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.RuleFuncList.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer -- return first index of value.<a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises ValueError if the value is not present.</p>
<p>Supporting start and stop arguments is optional, but
recommended.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.rule.RuleFuncList.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>i</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="LiSE.rule.RuleFuncListDescriptor">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">RuleFuncListDescriptor</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncListDescriptor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncListDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Descriptor that lets you get and set a whole RuleFuncList at once</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.rule.RuleMapping">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">RuleMapping</code><span class="sig-paren">(</span><em>engine</em>, <em>rulebook</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a <a class="reference internal" href="#LiSE.rule.RuleBook" title="LiSE.rule.RuleBook"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code></a> so you can get its rules by name.</p>
<p>You can access the rules in this either dictionary-style or as
attributes. This is for convenience if you want to get at a rule’s
decorators, eg. to add an Action to the rule.</p>
<p>Using this as a decorator will create a new rule, named for the
decorated function, and using the decorated function as the
initial Action.</p>
<p>Using this like a dictionary will let you create new rules,
appending them onto the underlying <a class="reference internal" href="#LiSE.rule.RuleBook" title="LiSE.rule.RuleBook"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code></a>; replace one
rule with another, where the new one will have the same index in
the <a class="reference internal" href="#LiSE.rule.RuleBook" title="LiSE.rule.RuleBook"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code></a> as the old one; and activate or deactivate
rules. The name of a rule may be used in place of the actual rule,
so long as the rule already exists.</p>
</dd></dl>

<dl class="class">
<dt id="LiSE.rule.TriggerList">
<em class="property">class </em><code class="descclassname">LiSE.rule.</code><code class="descname">TriggerList</code><span class="sig-paren">(</span><em>rule</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#TriggerList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.TriggerList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of trigger functions for rules</p>
</dd></dl>

<dl class="function">
<dt id="LiSE.rule.roundtrip_dedent">
<code class="descclassname">LiSE.rule.</code><code class="descname">roundtrip_dedent</code><span class="sig-paren">(</span><em>source</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#roundtrip_dedent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.roundtrip_dedent" title="Permalink to this definition">¶</a></dt>
<dd><p>Reformat some lines of code into what unparse makes.</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.query">
<span id="query"></span><h2>query<a class="headerlink" href="#module-LiSE.query" title="Permalink to this headline">¶</a></h2>
<p>The query engine provides Pythonic methods to access the database.</p>
<p>This module also contains a notably unfinished implementation of a query
language specific to LiSE. Access some stats using entities’ method
<code class="docutils literal notranslate"><span class="pre">historical</span></code>, and do comparisons on those, and instead of a boolean
result you’ll get a callable object that will return an iterator over
turn numbers in which the comparison evaluated to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="class">
<dt id="LiSE.query.QueryEngine">
<em class="property">class </em><code class="descclassname">LiSE.query.</code><code class="descname">QueryEngine</code><span class="sig-paren">(</span><em>dbstring</em>, <em>connect_args</em>, <em>alchemy</em>, <em>pack=None</em>, <em>unpack=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="LiSE.query.QueryEngine.exist_edge">
<code class="descname">exist_edge</code><span class="sig-paren">(</span><em>character</em>, <em>orig</em>, <em>dest</em>, <em>idx</em>, <em>branch</em>, <em>turn</em>, <em>tick</em>, <em>extant=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine.exist_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine.exist_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare whether or not this edge exists.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.query.QueryEngine.exist_node">
<code class="descname">exist_node</code><span class="sig-paren">(</span><em>character</em>, <em>node</em>, <em>branch</em>, <em>turn</em>, <em>tick</em>, <em>extant</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine.exist_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine.exist_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the node exists or doesn’t.</p>
<p>Inserts a new record or updates an old one, as needed.</p>
</dd></dl>

<dl class="method">
<dt id="LiSE.query.QueryEngine.initdb">
<code class="descname">initdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine.initdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine.initdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the database schema, both for allegedb and the special
extensions for LiSE</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="LiSE.query.slow_iter_turns_eval_cmp">
<code class="descclassname">LiSE.query.</code><code class="descname">slow_iter_turns_eval_cmp</code><span class="sig-paren">(</span><em>qry</em>, <em>oper</em>, <em>start_branch=None</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#slow_iter_turns_eval_cmp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.slow_iter_turns_eval_cmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all turns on which a comparison holds.</p>
<p>This is expensive. It evaluates the query for every turn in history.</p>
</dd></dl>

<dl class="function">
<dt id="LiSE.query.windows_intersection">
<code class="descclassname">LiSE.query.</code><code class="descname">windows_intersection</code><span class="sig-paren">(</span><em>windows</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#windows_intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.windows_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of (beginning, ending), return another describing where they overlap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)">list</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="LiSE.query.windows_union">
<code class="descclassname">LiSE.query.</code><code class="descname">windows_union</code><span class="sig-paren">(</span><em>windows</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#windows_union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.windows_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of (beginning, ending), return a minimal version that contains the same ranges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)">list</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">LiSE</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../allegedb/index.html">allegedb</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">LiSE</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.engine">engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.character">character</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.node">node</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.place">place</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.thing">thing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.portal">portal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.rule">rule</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.query">query</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ELiDE/index.html">ELiDE</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../allegedb/index.html" title="previous chapter">allegedb</a></li>
      <li>Next: <a href="../ELiDE/index.html" title="next chapter">ELiDE</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Zachary Spector.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/LiSE/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>