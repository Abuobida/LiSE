* database
** DONE change loaders so they can handle the case where you try to load something that doesn't exist
** schema changes
* interface
** place places (w. spots)
** place things (w. pawns)
** properties windows
*** Link items to characters and vice versa.
*** Little nested list demonstrating containment hierarchy.
** the hand
*** arrange cards manually or automatically
*** push cards aside to provide a drop zone
*** cards
**** with image
**** without
* AI
  Taking a page from... er, someone's *description of* Renderware AI
** Perception
   Some ways to automagically construct and maintain dimensions representing a character's *perception of* the gameworld, rather than the model that the game resolves conflicts with.
** Decision
   Algorithms acting on those perception graphs. Often this is just
   pathfinding--though it may operate on a graph representing
   *possible world states as perceived by the character*, with each
   node on the graph containing a perception graph of its own. At that
   point you're doing dynamic programming.
** Action
   The bit that executes the plans made by the decision part, and
   perhaps makes small adjustments to those plans when the world
   changes but not so much that you have to start over. Some
   roadblocks may be bypassed by just waiting for them to go away, for
   instance.
* Basic features
  In my opinion, every life sim should have these.
** Characters
*** Body model
**** Standard parts
***** Humans
***** Dogs, cats
***** Mechanical bits
*** Mind/spirit model
**** NPC scripting
**** NPC narrow AI
**** Knowledge tracking
*** Skill model
*** Sense model
**** Sight
***** What's here
***** What's inside
***** What does it resemble
**** Mistaken impressions
**** Incomplete impressions
** Day/night cycle
*** Arbitrary number of day-periods, which are not necessarily the smallest meaningful units of time, but which are the smallest units that can be scheduled for
*** NPCs follow no-thought scripts for each day, unless and until interrupted
**** The behavior solver will need to know what of the NPC's interests have been served by that point
**** To that effect, I will also need a need tracker
***** This will take the NPC's current wishes as parameters and track how they're being served
***** This information takes the same form that the solver will use
***** It has conditions under which it instantiates a solver, taking the wishes and their need-states, and gives the solver control of the NPC
****** These conditions may be thresholds that the need-states can pass
****** They may be world-states that the NPC is intimately concerned with, eg. a physician getting a call about a patient that they must immediately operate upon
****** The NPC should pretty much always wake up and pay attention whenever the player character interacts with them directly.
** Programming interface
* Extra features
** Stolen from Kudos 2
*** the social web display
*** the kudos bar
*** Significant Others
*** smallish menu of "good ideas"
But not restricted to stuff you've "unlocked," just stuff you *know
about* and which your character considers sensible.

Actually this should just be a sorting priority for the action inventory.
** Stolen from Redshirt
*** the *navigable* social web display
*** feeds of character activities
**** per character
**** per location
**** text mode
     Calendar mode also. Redshirt doesn't have that!
** Stolen from Dwarf Fortress
* Gameplay cycle
Depending on how many characters you control, and how far each will obey your instructions, it might be an rpg or a time/resource mgmt sim. In either case you collect resource and skill so you can learn of new opportunities to get more resource and skill. The middle-term objectives, possibly "missions," mostly involve raising some stat to some threshold, whether it's money, exp, or coolness. Any time a stat has an effect on the world, it will also (sometimes only) modify other stats that the player should be concerned with.

Sometimes you're actually trying to instantiate some new entity into the world, for which you need to sacrifice some other entity, or one of its stats. This makes a compelling kind of objective because creation has similar effects on the world model to exploration, yet is under player control. I'll pay special attention to enabling strange and unusual crafting systems. Like maybe you can craft entire cities. Abstraction is wonderful for that kind of thing.

* Time model
** Branch
   A branch is a sequence of predetermined ticks. Branches are indexed
   like lists, with the index assigned as the branch is
   created--there's no need for branches created later on to be
   "later" in the time model than any other branch.

   Each branch has a start tick and a parent branch, the lone
   exception being branch 0, which starts at tick 0 and has no parent
   branch.

   Branches can contain no random outcomes--so when there is a random
   outcome, a new branch is created, which *assumes* that particular
   outcome. This remains true when there are multiple random outcomes
   in a single tick: as each random effect is resolved, a new branch
   is created to account for it, and so long as it isn't the *last*
   random effect of the tick, the new branch will only contain one
   tick.

   For the time model's purposes, there is no distinction between a
   random outcome and a player's choice. Either will cause a new
   branch to be created. The random number or player input that
   resulted in the branch's creation will be recorded in the branch's
   header.
** Tick
   A tick is an atomic unit of time. Everything that happens in a tick
   is "simultaneous," although effects will nonetheless be resolved in a
   deterministic order.

   You might say that ticks "contain" effects from many branches, but
   not really. Ticks and branches are more like axes on a Cartesian
   plane: you use the two of them together to identify when you want
   something. But ticks are spaced regularly, where branches may be
   more or less densely packed depending on how much randomness is
   going on.

