* database
** DONE change loaders so they can handle the case where you try to load something that doesn't exist
** schema changes
*** [2014-04-15 Tue]
    While building the character sheet widget I noticed a discrepancy
    between the widget and the data model it was supposed to
    represent. You had to add things to the widget independently of
    adding them to the world, yet things were always in characters,
    regardless of whether they were in that character's widget.

    At first I tried responding by rewriting the widget. Probably
    needed to happen anyway because it was getting bloated. The idea
    was to rewrite it so it was just a view onto a character, perhaps
    filtered by a facade. But then I looked into the data model and
    wondered why I needed everything part of a character anyway.

    Characters are where graphs live, and everything that has a
    location, has it in a graph. Those were my assumptions...though,
    originally, graphs were separate from characters. They were called
    "dimensions," remember that? I stopped using them because I'd
    thought of a way to do without the distinction between a dimension
    and a character. I still think it's good to do without if I can.

    So these "character sheets," what do they show, exactly? Facades?
    The idea with facades was to let you see someone or something
    *from a particular point of view*. I'd done that by having one
    character look at another character and generate data about them
    based on whatever code, filtering what's in the observed
    character. That approach would still work if things and places and
    portals weren't inherently parts of characters, just grouped that
    way by your code.

    If characters aren't in the data model, and it's just dimensions
    full of things, places, and portals... well, that's even simpler,
    isn't it? Characters become SELECT, facades become WHERE, sort
    of. I could still cache the stuff that's in a character in any
    given tick. But it would no longer be a defining part of anything.
*** Character centric model
    Everything's part of exactly one Character, though possibly
    located in another.

    Characters act as namespaces and perhaps also fulfill the role of
    objects, per OOP.
**** Advantages
     Permanent namespaces where you only code within one character
     might be convenient...

     Fewer distinct entities in the data model to keep track of.
**** Disadvantages
     Permanent namespaces are also limiting: think of how to transfer
     part of one person's inventory to another.

     Difficult to iterate over all the things located in a given
     character but not *part of* that character.

     Kind of confusing to distinguish "located in" from "part of".
*** Dimension centric model
    Dimensions are graphs. The nodes are Places. The edges are
    Portals. Things move about on top.

    Characters collect some of those every tick. Facades mess up
    Characters into what somebody actually sees.
**** Advantages
     More customizable.

     More convenient when you don't care about subjectivity.
**** Disadvantages
     Fewer integrity constraints; more opportunities to get confused
     as to what's in a character.

     Recording what's in a character at every tick, while implementing
     foreign key constraints for the lot of it, means about double the
     number of distinct tables.

     If I *don't* record what's in a character every tick, and instead
     query the underlying dimension every tick, that means requerying
     every time I review the same tick. Makes it pretty important to
     optimize that query.
** ORM
   In orm.py mostly. Note there is no actual *class* called "ORM".
* interface
** place places (w. spots)
*** pick graphics
    Using SwatchBox.

    This used to work but is now broken. Tracking down the exact
    reason proves tricky because I used indirect methods of
    instantiating the SwatchBox, its container, and the other widgets
    thereabout. I think I was trying to keep things out of Python and
    in Kivy. I no longer think this was a good idea, if I ever did.

    I want one method to make a pop-over that is appropriate to my
    layout. It should take a FloatLayout or RelativeLayout for its
    argument, and display the contents in the pop-over.

    When the stuff in a widget depends on *prior* user input, that
    widget should be constructed in pure Python, not kv.
** place things (w. pawns)
** character sheets
*** Actually present the contents of facades.
    Called "character sheets" anyway because that's what they LOOK like.
*** Present said content in a default view that looks like a table.
    In fact it's a list. Perchance, a ListView.
*** Handles with which to reorder everything
*** Button next to each variable that lets you turn it into a calendar and back again.
    So that you can see what the variable was set to, and what it will
    be.

    Perhaps calendars should be resizeable, or perhaps pop-out-able,
    or both?
*** "Hide" button
    In developer mode this just shunts the var into an item at the
    bottom that you can click to see what you've hidden, and maybe
    drag it back out again. In player mode that won't appear.

    I guess it should be possible to reveal things at specific times,
    but it would also be inconvenient for the charsheet to rearrange
    itself while the developer's looking.

    I'll store the arrangement with branches and ticks, but set them
    both to zero by default, and leave them there until I think of a
    good way to do it.
*** Pair of dropdowns to select the observed and the observer
    Probably not gonna be visible in the player view.

    Each combination gets its own charsheet, which might have to be
    created when you select it. This specifically includes a
    character's view on itself.
** build events
*** How to get here?
    You can click through from an event on the calendar, or there's a
    menu item for it
*** How to pick the widgets herein?
    Similar to a file selector but these aren't files... each gets
    only one record in the database, which can participate in lots of
    relations.
*** causes
    They get a card and an "outie"
*** events
    They don't get proper cards, just boxes for their names--because,
    you see, players never see them. Also they need to be resized in a
    way the others just don't.

    Each starts with one "innie" and grows another when the last is filled in.
*** effects
    They get a card and an "innie"
** the hand
*** arrange cards manually or automatically
*** push cards aside to provide a drop zone
*** cards
**** with image
**** without
* AI
  Taking a page from... er, someone's *description of* Renderware AI
** Perception
   Some ways to automagically construct and maintain graphs
   representing a character's *perception of* the gameworld, rather
   than the model that the game resolves conflicts with.
** Decision
   Algorithms acting on those perception graphs. Often this is just
   pathfinding--though it may operate on a graph representing
   *possible world states as perceived by the character*, with each
   node on the graph containing a perception graph of its own. At that
   point you're doing dynamic programming.
** Action
   The bit that executes the plans made by the decision part, and
   perhaps makes small adjustments to those plans when the world
   changes but not so much that you have to start over. Some
   roadblocks may be bypassed by just waiting for them to go away, for
   instance.
* Programming interface
** branch, tick [2014-04-30 Wed]
   Every function that depends on the current diegetic time should
   pull it from the closet. That means no functions but those in the
   ORM should take (branch, tick) as parameters.
* Features stolen from Kudos 2
*** the social web display
*** the kudos bar
*** Significant Others
*** smallish menu of "good ideas"
But not restricted to stuff you've "unlocked," just stuff you *know
about* and which your character considers sensible.

Actually this should just be a sorting priority for the action inventory.
* Features stolen from Redshirt
*** the *navigable* social web display
*** feeds of character activities
**** per character
**** per location
**** text mode
     Calendar mode also. Redshirt doesn't have that!
* Features stolen from Dwarf Fortress
* Gameplay cycle
Depending on how many characters you control, and how far each will
obey your instructions, it might be an rpg or a time/resource mgmt
sim. In either case you collect resource and skill so you can learn of
new opportunities to get more resource and skill. The middle-term
objectives, possibly "missions," mostly involve raising some stat to
some threshold, whether it's money, exp, or coolness. Any time a stat
has an effect on the world, it will also (sometimes only) modify other
stats that the player should be concerned with.

Sometimes you're actually trying to instantiate some new entity into
the world, for which you need to sacrifice some other entity, or one
of its stats. This makes a compelling kind of objective because
creation has similar effects on the world model to exploration, yet is
under player control. I'll pay special attention to enabling strange
and unusual crafting systems. Like maybe you can craft entire
cities. Abstraction is wonderful for that kind of thing.

* Time model
** Branch
   A branch is a sequence of ticks. Branches are indexed
   like lists, with the index assigned as the branch is
   created--there's no need for branches created later on to be
   "later" in the time model than any other branch.

   Each branch has a start tick and a parent branch, the lone
   exception being branch 0, which starts at tick 0 and has no parent
   branch.

   Branches can contain no random outcomes--so when there is a random
   outcome, a new branch is created, which *assumes* that particular
   outcome. This remains true when there are multiple random outcomes
   in a single tick: as each random effect is resolved, a new branch
   is created to account for it, and so long as it isn't the *last*
   random effect of the tick, the new branch will only contain one
   tick.

   For the time model's purposes, there is no distinction between a
   random outcome and a player's choice. Either will cause a new
   branch to be created. The random number or player input that
   resulted in the branch's creation will be recorded in the branch's
   header.
** Tick
   A tick is an atomic unit of time. Everything that happens in a tick
   is "simultaneous," although effects will nonetheless be resolved in a
   deterministic order.

   You might say that ticks "contain" effects from many branches, but
   not really. Ticks and branches are more like axes on a Cartesian
   plane: you use the two of them together to identify when you want
   something.
