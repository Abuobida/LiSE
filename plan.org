* database
** DONE change loaders so they can handle the case where you try to load something that doesn't exist
** schema changes
** ORM
   In orm.py mostly. Note there is no actual *class* called "ORM".
*** 
* interface
** place places (w. spots)
*** pick graphics
    Using SwatchBox.

    This used to work but is now broken. Tracking down the exact
    reason proves tricky because I used indirect methods of
    instantiating the SwatchBox, its container, and the other widgets
    thereabout. I think I was trying to keep things out of Python and
    in Kivy. I no longer think this was a good idea, if I ever did.

    I want one method to make a pop-over that is appropriate to my
    layout. It should take a FloatLayout or RelativeLayout for its
    argument, and display the contents in the pop-over.

    When the stuff in a widget depends on *prior* user input, that
    widget should be constructed in pure Python, not kv.
** place things (w. pawns)
** character sheets
*** Actually present the contents of facades.
    Called "character sheets" anyway because that's what they LOOK like.
*** Present said content in a default view that looks like a table.
    In fact it's a list. Perchance, a ListView.
*** Handles with which to reorder everything
*** Button next to each variable that lets you turn it into a calendar and back again.
    So that you can see what the variable was set to, and what it will
    be.

    Perhaps calendars should be resizeable, or perhaps pop-out-able,
    or both?
*** "Hide" button
    In developer mode this just shunts the var into an item at the
    bottom that you can click to see what you've hidden, and maybe
    drag it back out again. In player mode that won't appear.

    I guess it should be possible to reveal things at specific times,
    but it would also be inconvenient for the charsheet to rearrange
    itself while the developer's looking.

    I'll store the arrangement with branches and ticks, but set them
    both to zero by default, and leave them there until I think of a
    good way to do it.
*** Pair of dropdowns to select the observed and the observer
    Probably not gonna be visible in the player view.

    Each combination gets its own charsheet, which might have to be
    created when you select it. This specifically includes a
    character's view on itself.
** build events
*** How to get here?
    You can click through from an event on the calendar, or there's a
    menu item for it
*** How to pick the widgets herein?
    Similar to a file selector but these aren't files... each gets
    only one record in the database, which can participate in lots of
    relations.
*** causes
    They get a card and an "outie"
*** events
    They don't get proper cards, just boxes for their names--because,
    you see, players never see them. Also they need to be resized in a
    way the others just don't.

    Each starts with one "innie" and grows another when the last is filled in.
*** effects
    They get a card and an "innie"
** the hand
*** arrange cards manually or automatically
*** push cards aside to provide a drop zone
*** cards
**** with image
**** without
* AI
  Taking a page from... er, someone's *description of* Renderware AI
** Perception
   Some ways to automagically construct and maintain dimensions representing a character's *perception of* the gameworld, rather than the model that the game resolves conflicts with.
** Decision
   Algorithms acting on those perception graphs. Often this is just
   pathfinding--though it may operate on a graph representing
   *possible world states as perceived by the character*, with each
   node on the graph containing a perception graph of its own. At that
   point you're doing dynamic programming.
** Action
   The bit that executes the plans made by the decision part, and
   perhaps makes small adjustments to those plans when the world
   changes but not so much that you have to start over. Some
   roadblocks may be bypassed by just waiting for them to go away, for
   instance.
* Basic features
  In my opinion, every life sim should have these.
** Characters
*** Body model
**** Standard parts
***** Humans
***** Dogs, cats
***** Mechanical bits
*** Mind/spirit model
**** NPC scripting
**** NPC narrow AI
**** Knowledge tracking
*** Skill model
*** Sense model
**** Sight
***** What's here
***** What's inside
***** What does it resemble
**** Mistaken impressions
**** Incomplete impressions
** Day/night cycle
*** Arbitrary number of day-periods, which are not necessarily the smallest meaningful units of time, but which are the smallest units that can be scheduled for
*** NPCs follow no-thought scripts for each day, unless and until interrupted
**** The behavior solver will need to know what of the NPC's interests have been served by that point
**** To that effect, I will also need a need tracker
***** This will take the NPC's current wishes as parameters and track how they're being served
***** This information takes the same form that the solver will use
***** It has conditions under which it instantiates a solver, taking the wishes and their need-states, and gives the solver control of the NPC
****** These conditions may be thresholds that the need-states can pass
****** They may be world-states that the NPC is intimately concerned with, eg. a physician getting a call about a patient that they must immediately operate upon
****** The NPC should pretty much always wake up and pay attention whenever the player character interacts with them directly.
** Programming interface
*** Event infrastructure
**** TODO Turn existing Journeys into events
* Extra features
** Stolen from Kudos 2
*** the social web display
*** the kudos bar
*** Significant Others
*** smallish menu of "good ideas"
But not restricted to stuff you've "unlocked," just stuff you *know
about* and which your character considers sensible.

Actually this should just be a sorting priority for the action inventory.
** Stolen from Redshirt
*** the *navigable* social web display
*** feeds of character activities
**** per character
**** per location
**** text mode
     Calendar mode also. Redshirt doesn't have that!
** Stolen from Dwarf Fortress
* Gameplay cycle
Depending on how many characters you control, and how far each will
obey your instructions, it might be an rpg or a time/resource mgmt
sim. In either case you collect resource and skill so you can learn of
new opportunities to get more resource and skill. The middle-term
objectives, possibly "missions," mostly involve raising some stat to
some threshold, whether it's money, exp, or coolness. Any time a stat
has an effect on the world, it will also (sometimes only) modify other
stats that the player should be concerned with.

Sometimes you're actually trying to instantiate some new entity into
the world, for which you need to sacrifice some other entity, or one
of its stats. This makes a compelling kind of objective because
creation has similar effects on the world model to exploration, yet is
under player control. I'll pay special attention to enabling strange
and unusual crafting systems. Like maybe you can craft entire
cities. Abstraction is wonderful for that kind of thing.

* Time model
** Branch
   A branch is a sequence of ticks. Branches are indexed
   like lists, with the index assigned as the branch is
   created--there's no need for branches created later on to be
   "later" in the time model than any other branch.

   Each branch has a start tick and a parent branch, the lone
   exception being branch 0, which starts at tick 0 and has no parent
   branch.

   Branches can contain no random outcomes--so when there is a random
   outcome, a new branch is created, which *assumes* that particular
   outcome. This remains true when there are multiple random outcomes
   in a single tick: as each random effect is resolved, a new branch
   is created to account for it, and so long as it isn't the *last*
   random effect of the tick, the new branch will only contain one
   tick.

   For the time model's purposes, there is no distinction between a
   random outcome and a player's choice. Either will cause a new
   branch to be created. The random number or player input that
   resulted in the branch's creation will be recorded in the branch's
   header.
** Tick
   A tick is an atomic unit of time. Everything that happens in a tick
   is "simultaneous," although effects will nonetheless be resolved in a
   deterministic order.

   You might say that ticks "contain" effects from many branches, but
   not really. Ticks and branches are more like axes on a Cartesian
   plane: you use the two of them together to identify when you want
   something.

* switchover to character centric database

** character
*** thing
**** get [3/3]
***** DONE get_thing_bone
***** DONE get_thing_locations
***** DONE get_thing_location
**** set [3/3]
***** DONE set_thing_bone
***** DONE set_thing_location
***** DONE set_thing_idx
*** place
**** get [2/3]
***** DONE get_place_bone
***** DONE get_place_contents
***** TODO get_place_incident
      I guess that just means portals from/to?
**** set [2/2]
***** DONE set_place_bone
***** DONE set_place_idx
*** portal
**** get [3/3]
***** DONE get_portal_bone
***** DONE get_portal_origin
***** DONE get_portal_destination
**** set [4/4]
***** DONE set_portal_bone
***** DONE set_portal_origin
***** DONE set_portal_destination
***** DONE set_portal_dimension
*** stat
**** get [2/2]
***** DONE get_stat_bone
***** DONE get_stat_val
**** set [2/2]
***** DONE set_stat_bone
***** DONE set_stat_val
** facade
*** thing
**** get [1/1]
***** DONE get_thing_bone
**** set [1/1]
***** DONE set_thing_bone
*** place
**** get [1/1]
***** DONE get_place_bone
**** set [1/1]
***** DONE set_place_bone
*** portal
**** get [1/1]
***** DONE get_portal_bone
**** set [1/1]
***** DONE set_portal_bone
*** stat
**** get [1/1]
***** DONE get_stat_bone
**** set [1/1]
***** DONE set_stat_bone

